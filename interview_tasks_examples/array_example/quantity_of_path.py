# https://www.youtube.com/watch?v=GhiRlhPlJ9Q

def quantity_of_path_recursive(n: int, m: int) -> int:
    if n < 1 or m < 1:
        return 0
    if n == 1 and m == 1:
        return 1

    return quantity_of_path_recursive(n - 1, m) + quantity_of_path_recursive(n, m - 1)


def quantity_of_path_dynamic(n: int, m: int) -> int:
    # Проверка граничных условий
    if n < 1 or m < 1:
        return 0
    if n == 1 and m == 1:
        return 1

    # Создаем массив для хранения количества путей
    arr = [[0 for _ in range(m)] for _ in range(n)]

    # Заполняем первую строку и первый столбец единицами, так как туда можно добраться только одним способом
    for i in range(n):
        arr[i][0] = 1
    for j in range(m):
        arr[0][j] = 1

    # Заполняем остальную часть массива
    for i in range(1, n):
        for j in range(1, m):
            arr[i][j] = arr[i - 1][j] + arr[i][j - 1]

    return arr[n - 1][m - 1]


"""
Объяснение
1. Проверка граничных условий:
    Если n<1 или m<1, возвращаем 0, так как невозможные размеры.
    Если n=1 и m=1, возвращаем 1, так как на сетке 1x1 только один способ.
    Создание массива для хранения количества путей:

2. Создание массива для хранения количества путей:
    arr = [[0 for _ in range(m)] for _ in range(n)]: Создаем двумерный массив размером 
    n×m, заполненный нулями.
    
3. Заполнение первой строки и первого столбца:
    Путь в каждую клетку первой строки и первого столбца может быть только один (либо всегда двигаться вправо, 
    либо всегда двигаться вниз).
    
4. Заполнение остальной части массива:
    Каждый элемент массива 
    arr[i][j] заполняется суммой значений элемента сверху (arr[i−1][j]) 
    и элемента слева (arr[i][j−1]), так как это количество способов добраться до этой клетки.
    
5. Возвращаем результат:
    Значение в правом нижнем углу массива (arr[n−1][m−1]) является количеством путей для сетки размером n×m.
    
Этот подход использует динамическое программирование для решения задачи с временной сложностью 
O(n⋅m) и пространственной сложностью O(n⋅m).
"""


if __name__ == '__main__':
    x = 3
    y = 2

    out = quantity_of_path_recursive(x, y)
    print(out)

    out = quantity_of_path_dynamic(x, y)
    print(out)
